name: Deploy to AWS Elastic Beanstalk

on:
  push:
    branches: [ master ]
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Setup DynamoDB Tables
        run: |
          # Create financial_documents table if it doesn't exist
          aws dynamodb create-table \
            --table-name financial_documents \
            --attribute-definitions AttributeName=document_id,AttributeType=S \
            --key-schema AttributeName=document_id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region eu-central-1 || echo "Table financial_documents already exists"

          # Create document_analysis table if it doesn't exist
          aws dynamodb create-table \
            --table-name document_analysis \
            --attribute-definitions AttributeName=document_id,AttributeType=S \
            --key-schema AttributeName=document_id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region eu-central-1 || echo "Table document_analysis already exists"

          # Create chat_history table if it doesn't exist
          aws dynamodb create-table \
            --table-name chat_history \
            --attribute-definitions AttributeName=chat_id,AttributeType=S \
            --key-schema AttributeName=chat_id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region eu-central-1 || echo "Table chat_history already exists"

      # TODO: Review if DynamoDB table creation should be part of the deployment workflow or handled separately (e.g., IaC, manual setup).

      # TODO: Review if creating/overwriting secrets (SSM parameters) is necessary on every run.
      # Ensure the GitHub Actions runner has ssm:PutParameter permissions if this step is kept.
      - name: Create AWS Secrets if they don't exist
        run: |
          # Generate random secrets if they don't exist yet
          FLASK_SECRET_KEY=$(openssl rand -hex 24)
          JWT_SECRET=$(openssl rand -hex 24)

          # Create or update SSM parameters
          aws ssm put-parameter --name "SECRET_KEY" --value "$FLASK_SECRET_KEY" --type SecureString --overwrite --region eu-central-1 || true
          aws ssm put-parameter --name "JWT_SECRET" --value "$JWT_SECRET" --type SecureString --overwrite --region eu-central-1 || true
          aws ssm put-parameter --name "USE_DYNAMODB" --value "True" --type String --overwrite --region eu-central-1 || true
          aws ssm put-parameter --name "DYNAMODB_REGION" --value "eu-central-1" --type String --overwrite --region eu-central-1 || true

          # Add HuggingFace API key if provided as a secret
          if [ -n "${{ secrets.HUGGINGFACE_API_KEY }}" ]; then
            aws ssm put-parameter --name "HUGGINGFACE_API_KEY" --value "${{ secrets.HUGGINGFACE_API_KEY }}" --type SecureString --overwrite --region eu-central-1 || true
          fi

      - name: Create Elastic Beanstalk Application if it doesn't exist
        run: |
          # Check if application exists
          if ! aws elasticbeanstalk describe-applications --application-names financial-docs > /dev/null 2>&1; then
            echo "Creating Elastic Beanstalk application 'financial-docs'"
            aws elasticbeanstalk create-application --application-name financial-docs --description "Financial Documents Analysis Application"
          else
            echo "Application 'financial-docs' already exists"
          fi

      - name: Check for existing environment
        id: check-env
        run: |
          if aws elasticbeanstalk describe-environments --application-name financial-docs --environment-names financial-docs-env | grep -q "financial-docs-env"; then
            echo "Environment exists"
            echo "env_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Environment does not exist"
            echo "env_exists=false" >> $GITHUB_OUTPUT
          fi

      # Removed conflicting "List available solution stacks" step during merge

      - name: Create Elastic Beanstalk environment if it doesn't exist
        if: steps.check-env.outputs.env_exists == 'false'
        run: |
          echo "Creating Elastic Beanstalk environment 'financial-docs-env'"
          aws elasticbeanstalk create-environment \
            --application-name financial-docs \
            --environment-name financial-docs-env \
            # TODO: Replace with the latest valid Docker platform solution stack name for Amazon Linux 2023 from `aws elasticbeanstalk list-available-solution-stacks`
            --solution-stack-name "64bit Amazon Linux 2023 v4.x.x running Docker" \
            # Kept HEAD version using Docker platform during merge conflict resolution
            --option-settings '[
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "FLASK_ENV", "Value": "production"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "PORT", "Value": "10000"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "USE_DYNAMODB", "Value": "true"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "DYNAMODB_REGION", "Value": "eu-central-1"}
            ]'

      - name: Deploy to Elastic Beanstalk
        if: steps.check-env.outputs.env_exists == 'true'
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: financial-docs
          environment_name: financial-docs-env
          version_label: financial-docs-${{ github.sha }}
          region: eu-central-1
          deployment_package: deploy.zip # This needs to be generated if not using Dockerfile directly
          use_existing_version_if_available: false
          wait_for_environment_recovery: 300
