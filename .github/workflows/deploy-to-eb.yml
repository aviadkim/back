name: Deploy to AWS Elastic Beanstalk
on:
  push:
    branches: [ master ]
  workflow_dispatch:  # Allow manual triggering
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: List available solution stacks
        id: solution-stacks
        run: |
          STACKS=$(aws elasticbeanstalk list-available-solution-stacks --query "SolutionStacks[?contains(@, 'Docker') && contains(@, 'Amazon Linux 2023')] | [0]" --output text)
          echo "DOCKER_STACK=${STACKS}" >> $GITHUB_OUTPUT
          echo "Available Docker stack: ${STACKS}"
      
      - name: Create Elastic Beanstalk Application
        run: |
          # Force create the application (ignore if it already exists)
          aws elasticbeanstalk create-application \
            --application-name financial-docs \
            --description "Financial Documents Analysis Application" || true
      
      - name: Check environment status
        id: check-env
        run: |
          # Check if environment exists and get its status
          ENV_INFO=$(aws elasticbeanstalk describe-environments \
            --application-name financial-docs \
            --environment-names financial-docs-env 2>/dev/null || echo "NOT_FOUND")
          
          if echo "$ENV_INFO" | grep -q "NOT_FOUND" || ! echo "$ENV_INFO" | grep -q "EnvironmentName"; then
            echo "Environment does not exist"
            echo "env_exists=false" >> $GITHUB_OUTPUT
            echo "env_status=NOT_FOUND" >> $GITHUB_OUTPUT
          else
            echo "Environment exists"
            echo "env_exists=true" >> $GITHUB_OUTPUT
            
            # Extract status
            STATUS=$(echo "$ENV_INFO" | grep -o '"Status": "[^"]*"' | cut -d'"' -f4)
            echo "Environment status: $STATUS"
            echo "env_status=$STATUS" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate deployment package
        run: zip -r deploy.zip . -x "*.git*" "venv/*" "__pycache__/*"
      
      - name: Create Elastic Beanstalk environment if it doesn't exist
        if: steps.check-env.outputs.env_exists == 'false'
        run: |
          echo "Creating Elastic Beanstalk environment 'financial-docs-env'"
          aws elasticbeanstalk create-environment \
            --application-name financial-docs \
            --environment-name financial-docs-env \
            --solution-stack-name "${{ steps.solution-stacks.outputs.DOCKER_STACK }}" \
            --option-settings '[
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "FLASK_ENV", "Value": "production"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "PORT", "Value": "10000"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "USE_DYNAMODB", "Value": "true"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "DYNAMODB_REGION", "Value": "${{ secrets.AWS_REGION }}"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "DEFAULT_LANGUAGE", "Value": "he"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "HUGGINGFACE_API_KEY", "Value": "${{ secrets.HUGGINGFACE_API_KEY }}"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "SECRET_KEY", "Value": "28"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "JWT_SECRET", "Value": "210"},
              {"Namespace": "aws:elasticbeanstalk:application:environment", "OptionName": "SERVICE_NAME", "Value": "${{ secrets.SERVICE_NAME }}"}
            ]'
      
      - name: Wait for environment to be ready
        if: steps.check-env.outputs.env_exists == 'true' && steps.check-env.outputs.env_status != 'Ready'
        run: |
          echo "Waiting for environment to be ready..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT+1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            STATUS=$(aws elasticbeanstalk describe-environments \
              --application-name financial-docs \
              --environment-names financial-docs-env \
              --query "Environments[0].Status" --output text)
            
            echo "Current status: $STATUS"
            
            if [ "$STATUS" = "Ready" ]; then
              echo "Environment is ready!"
              break
            elif [ "$STATUS" = "Launching" ] || [ "$STATUS" = "Updating" ]; then
              echo "Environment is still $STATUS, waiting 30 seconds..."
              sleep 30
            else
              echo "Environment is in an unexpected state: $STATUS"
              # If environment is in a bad state like "Terminating", we'll try a deploy anyway
              # as the einaregilsson/beanstalk-deploy action will provide a better error message
              break
            fi
          done
      
      - name: Deploy to Elastic Beanstalk
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: financial-docs
          environment_name: financial-docs-env
          version_label: financial-docs-${{ github.sha }}
          region: ${{ secrets.AWS_REGION }}
          deployment_package: deploy.zip
          use_existing_version_if_available: false
          wait_for_environment_recovery: 300
